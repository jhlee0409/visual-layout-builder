import { describe, it, expect, beforeEach } from "vitest"
import { useLayoutStore } from "@/store/layout-store"

describe("Component Linking Concurrent Operations", () => {
  beforeEach(() => {
    // Reset store to empty state before each test
    const store = useLayoutStore.getState()
    store.resetSchema()
  })

  describe("Concurrent link additions", () => {
    it("should handle multiple link additions in sequence", () => {
      let store = useLayoutStore.getState()

      // Add components (IDs are auto-generated by addComponent)
      store.addComponent({
        name: "Header",
        semanticTag: "header",
        positioning: { type: "sticky", position: { top: 0 } },
        layout: { type: "flex", flex: { direction: "row" } },
      })
      store.addComponent({
        name: "Sidebar",
        semanticTag: "aside",
        positioning: { type: "static" },
        layout: { type: "flex", flex: { direction: "column" } },
      })
      store.addComponent({
        name: "Main",
        semanticTag: "main",
        positioning: { type: "static" },
        layout: { type: "flex", flex: { direction: "column" } },
      })

      // Get updated state and actual generated IDs
      store = useLayoutStore.getState()
      const components = store.schema.components
      const c1Id = components[0].id
      const c2Id = components[1].id
      const c3Id = components[2].id

      // Add multiple links in sequence (with 1-to-1 constraint)
      store.addComponentLink(c1Id, c2Id)  // c1-c2
      store.addComponentLink(c2Id, c3Id)  // c2-c3 (removes c1-c2 because c2 can only have 1 link)
      store.addComponentLink(c1Id, c3Id)  // c1-c3 (removes c2-c3 because c3 can only have 1 link)

      // Get updated state
      store = useLayoutStore.getState()
      const links = store.componentLinks
      expect(links.length).toBe(1)  // Only c1-c3 remains

      // Verify final connection
      const group = store.getLinkedComponentGroup(c1Id)
      expect(group).toContain(c1Id)
      expect(group).toContain(c3Id)
      expect(group).not.toContain(c2Id)  // c2 is no longer connected
    })

    it("should handle rapid link additions without duplication", () => {
      let store = useLayoutStore.getState()

      // Add multiple components
      for (let i = 0; i < 5; i++) {
        store.addComponent({
          name: `Component${i + 1}`,
          semanticTag: "section",
          positioning: { type: "static" },
          layout: { type: "flex", flex: { direction: "column" } },
        })
      }

      // Get updated state
      store = useLayoutStore.getState()
      const ids = store.schema.components.map((c) => c.id)

      // Add multiple links
      store.addComponentLink(ids[0], ids[1])
      store.addComponentLink(ids[1], ids[2])
      store.addComponentLink(ids[2], ids[3])
      store.addComponentLink(ids[3], ids[4])

      // Attempt duplicate link (should be prevented)
      store.addComponentLink(ids[0], ids[1])

      // Get updated state
      store = useLayoutStore.getState()
      const links = store.componentLinks
      // Should not have duplicate links
      const uniqueLinks = new Set(links.map((link) => `${link.source}-${link.target}`))
      expect(links.length).toBe(uniqueLinks.size)
    })
  })

  describe("Concurrent link removals", () => {
    it("should handle multiple link removals in sequence", () => {
      let store = useLayoutStore.getState()

      // Setup: Add components
      store.addComponent({
        name: "C1",
        semanticTag: "section",
        positioning: { type: "static" },
        layout: { type: "flex", flex: { direction: "column" } },
      })
      store.addComponent({
        name: "C2",
        semanticTag: "section",
        positioning: { type: "static" },
        layout: { type: "flex", flex: { direction: "column" } },
      })
      store.addComponent({
        name: "C3",
        semanticTag: "section",
        positioning: { type: "static" },
        layout: { type: "flex", flex: { direction: "column" } },
      })

      // Get updated state
      store = useLayoutStore.getState()
      const ids = store.schema.components.map((c) => c.id)

      // Add links (with 1-to-1 constraint)
      store.addComponentLink(ids[0], ids[1])  // id0-id1
      store.addComponentLink(ids[1], ids[2])  // id1-id2 (removes id0-id1 because id1 can only have 1 link)

      // Get updated state
      store = useLayoutStore.getState()
      const linksBefore = store.componentLinks.length
      expect(linksBefore).toBe(1)  // Only id1-id2 remains

      // Remove link
      store.removeComponentLink(ids[1], ids[2])

      // Get updated state
      store = useLayoutStore.getState()
      const linksAfter = store.componentLinks.length
      expect(linksAfter).toBe(0)
    })
  })

  describe("Mixed concurrent operations", () => {
    it("should handle mixed add/remove operations", () => {
      let store = useLayoutStore.getState()

      // Add components
      for (let i = 0; i < 4; i++) {
        store.addComponent({
          name: `Component${i + 1}`,
          semanticTag: "section",
          positioning: { type: "static" },
          layout: { type: "flex", flex: { direction: "column" } },
        })
      }

      // Get updated state
      store = useLayoutStore.getState()
      const ids = store.schema.components.map((c) => c.id)

      // Mixed operations (with 1-to-1 constraint)
      store.addComponentLink(ids[0], ids[1])  // id0-id1
      store.addComponentLink(ids[1], ids[2])  // id1-id2 (removes id0-id1)
      store.removeComponentLink(ids[0], ids[1]) // No effect (id0-id1 already removed)
      store.addComponentLink(ids[2], ids[3])  // id2-id3 (removes id1-id2)

      // Get updated state
      store = useLayoutStore.getState()
      const links = store.componentLinks
      expect(links.length).toBe(1) // Only ids[2]-ids[3] remains

      // Verify groups
      const group1 = store.getLinkedComponentGroup(ids[0])
      expect(group1.length).toBe(1) // ids[0] is alone

      const group2 = store.getLinkedComponentGroup(ids[1])
      expect(group2.length).toBe(1) // ids[1] is alone

      const group3 = store.getLinkedComponentGroup(ids[2])
      expect(group3).toContain(ids[2])
      expect(group3).toContain(ids[3])
      expect(group3.length).toBe(2)
    })

    it("should maintain consistency when deleting component with links", () => {
      let store = useLayoutStore.getState()

      // Add components and links
      store.addComponent({
        name: "C1",
        semanticTag: "section",
        positioning: { type: "static" },
        layout: { type: "flex", flex: { direction: "column" } },
      })
      store.addComponent({
        name: "C2",
        semanticTag: "section",
        positioning: { type: "static" },
        layout: { type: "flex", flex: { direction: "column" } },
      })
      store.addComponent({
        name: "C3",
        semanticTag: "section",
        positioning: { type: "static" },
        layout: { type: "flex", flex: { direction: "column" } },
      })

      // Get updated state
      store = useLayoutStore.getState()
      const ids = store.schema.components.map((c) => c.id)

      store.addComponentLink(ids[0], ids[1])  // id0-id1
      store.addComponentLink(ids[1], ids[2])  // id1-id2 (removes id0-id1 because id1 can only have 1 link)

      // Get updated state
      store = useLayoutStore.getState()
      expect(store.componentLinks.length).toBe(1)  // Only id1-id2 remains

      // Delete component ids[1] (should remove all related links)
      store.deleteComponent(ids[1])

      // Get updated state
      store = useLayoutStore.getState()
      const linksAfter = store.componentLinks
      expect(linksAfter.length).toBe(0) // All links involving ids[1] should be removed
      expect(linksAfter.some((link) => link.source === ids[1] || link.target === ids[1])).toBe(false)
    })
  })

  describe("Edge cases with concurrent operations", () => {
    it("should handle clear all links with existing links", () => {
      let store = useLayoutStore.getState()

      // Add components and multiple links
      for (let i = 0; i < 5; i++) {
        store.addComponent({
          name: `Component${i + 1}`,
          semanticTag: "section",
          positioning: { type: "static" },
          layout: { type: "flex", flex: { direction: "column" } },
        })
      }

      // Get updated state
      store = useLayoutStore.getState()
      const ids = store.schema.components.map((c) => c.id)

      // Create a complex network
      store.addComponentLink(ids[0], ids[1])
      store.addComponentLink(ids[1], ids[2])
      store.addComponentLink(ids[2], ids[3])
      store.addComponentLink(ids[3], ids[4])

      // Get updated state
      store = useLayoutStore.getState()
      expect(store.componentLinks.length).toBeGreaterThan(0)

      // Clear all links
      store.clearAllLinks()

      // Get updated state
      store = useLayoutStore.getState()
      expect(store.componentLinks.length).toBe(0)
    })
  })

  describe("Performance and consistency", () => {
    it("should maintain consistency with many components and links", () => {
      let store = useLayoutStore.getState()

      // Add many components
      const numComponents = 20
      for (let i = 0; i < numComponents; i++) {
        store.addComponent({
          name: `Component${i + 1}`,
          semanticTag: "section",
          positioning: { type: "static" },
          layout: { type: "flex", flex: { direction: "column" } },
        })
      }

      // Get updated state
      store = useLayoutStore.getState()
      const ids = store.schema.components.map((c) => c.id)

      // Create a chain of links (with 1-to-1 constraint)
      // Each addComponentLink will remove the previous link of the shared component
      for (let i = 0; i < numComponents - 1; i++) {
        store.addComponentLink(ids[i], ids[i + 1])
      }

      // Get updated state
      store = useLayoutStore.getState()
      const links = store.componentLinks
      // With 1-to-1 constraint, only the last link remains (id18-id19)
      expect(links.length).toBe(1)

      // Only the last two components should be linked
      const lastGroup = store.getLinkedComponentGroup(ids[numComponents - 2])
      expect(lastGroup).toContain(ids[numComponents - 2])
      expect(lastGroup).toContain(ids[numComponents - 1])
      expect(lastGroup.length).toBe(2)

      // First component should be alone
      const firstGroup = store.getLinkedComponentGroup(ids[0])
      expect(firstGroup.length).toBe(1)
    })
  })
})
