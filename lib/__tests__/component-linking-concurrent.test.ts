import { describe, it, expect, beforeEach } from "vitest"
import { useLayoutStore } from "@/store/layout-store"

describe("Component Linking Concurrent Operations", () => {
  beforeEach(() => {
    // Reset store to empty state before each test
    const store = useLayoutStore.getState()
    store.resetSchema()
  })

  describe("Concurrent link additions", () => {
    it("should handle multiple link additions in sequence", () => {
      let store = useLayoutStore.getState()

      // Add components (IDs are auto-generated by addComponent)
      store.addComponent({
        name: "Header",
        semanticTag: "header",
        positioning: { type: "sticky", position: { top: 0 } },
        layout: { type: "flex", flex: { direction: "row" } },
      })
      store.addComponent({
        name: "Sidebar",
        semanticTag: "aside",
        positioning: { type: "static" },
        layout: { type: "flex", flex: { direction: "column" } },
      })
      store.addComponent({
        name: "Main",
        semanticTag: "main",
        positioning: { type: "static" },
        layout: { type: "flex", flex: { direction: "column" } },
      })

      // Get updated state and actual generated IDs
      store = useLayoutStore.getState()
      const components = store.schema.components
      const c1Id = components[0].id
      const c2Id = components[1].id
      const c3Id = components[2].id

      // Add multiple links in sequence
      store.addComponentLink(c1Id, c2Id)
      store.addComponentLink(c2Id, c3Id)
      store.addComponentLink(c1Id, c3Id) // Should be deduplicated by transitive connection

      // Get updated state
      store = useLayoutStore.getState()
      const links = store.componentLinks
      expect(links.length).toBeGreaterThan(0)

      // Verify transitive connections
      const group = store.getLinkedComponentGroup(c1Id)
      expect(group).toContain(c1Id)
      expect(group).toContain(c2Id)
      expect(group).toContain(c3Id)
    })

    it("should handle rapid link additions without duplication", () => {
      let store = useLayoutStore.getState()

      // Add multiple components
      for (let i = 0; i < 5; i++) {
        store.addComponent({
          name: `Component${i + 1}`,
          semanticTag: "section",
          positioning: { type: "static" },
          layout: { type: "flex", flex: { direction: "column" } },
        })
      }

      // Get updated state
      store = useLayoutStore.getState()
      const ids = store.schema.components.map((c) => c.id)

      // Add multiple links
      store.addComponentLink(ids[0], ids[1])
      store.addComponentLink(ids[1], ids[2])
      store.addComponentLink(ids[2], ids[3])
      store.addComponentLink(ids[3], ids[4])

      // Attempt duplicate link (should be prevented)
      store.addComponentLink(ids[0], ids[1])

      // Get updated state
      store = useLayoutStore.getState()
      const links = store.componentLinks
      // Should not have duplicate links
      const uniqueLinks = new Set(links.map((link) => `${link.source}-${link.target}`))
      expect(links.length).toBe(uniqueLinks.size)
    })
  })

  describe("Concurrent link removals", () => {
    it("should handle multiple link removals in sequence", () => {
      let store = useLayoutStore.getState()

      // Setup: Add components
      store.addComponent({
        name: "C1",
        semanticTag: "section",
        positioning: { type: "static" },
        layout: { type: "flex", flex: { direction: "column" } },
      })
      store.addComponent({
        name: "C2",
        semanticTag: "section",
        positioning: { type: "static" },
        layout: { type: "flex", flex: { direction: "column" } },
      })
      store.addComponent({
        name: "C3",
        semanticTag: "section",
        positioning: { type: "static" },
        layout: { type: "flex", flex: { direction: "column" } },
      })

      // Get updated state
      store = useLayoutStore.getState()
      const ids = store.schema.components.map((c) => c.id)

      // Add links
      store.addComponentLink(ids[0], ids[1])
      store.addComponentLink(ids[1], ids[2])

      // Get updated state
      store = useLayoutStore.getState()
      const linksBefore = store.componentLinks.length
      expect(linksBefore).toBe(2)

      // Remove links in sequence
      store.removeComponentLink(ids[0], ids[1])
      store.removeComponentLink(ids[1], ids[2])

      // Get updated state
      store = useLayoutStore.getState()
      const linksAfter = store.componentLinks.length
      expect(linksAfter).toBe(0)
    })
  })

  describe("Mixed concurrent operations", () => {
    it("should handle mixed add/remove operations", () => {
      let store = useLayoutStore.getState()

      // Add components
      for (let i = 0; i < 4; i++) {
        store.addComponent({
          name: `Component${i + 1}`,
          semanticTag: "section",
          positioning: { type: "static" },
          layout: { type: "flex", flex: { direction: "column" } },
        })
      }

      // Get updated state
      store = useLayoutStore.getState()
      const ids = store.schema.components.map((c) => c.id)

      // Mixed operations
      store.addComponentLink(ids[0], ids[1])
      store.addComponentLink(ids[1], ids[2])
      store.removeComponentLink(ids[0], ids[1]) // Remove first link
      store.addComponentLink(ids[2], ids[3])

      // Get updated state
      store = useLayoutStore.getState()
      const links = store.componentLinks
      expect(links.length).toBe(2) // ids[1]-ids[2], ids[2]-ids[3]

      // Verify groups
      const group1 = store.getLinkedComponentGroup(ids[0])
      expect(group1.length).toBe(1) // ids[0] is now alone

      const group2 = store.getLinkedComponentGroup(ids[1])
      expect(group2).toContain(ids[1])
      expect(group2).toContain(ids[2])
      expect(group2).toContain(ids[3])
    })

    it("should maintain consistency when deleting component with links", () => {
      let store = useLayoutStore.getState()

      // Add components and links
      store.addComponent({
        name: "C1",
        semanticTag: "section",
        positioning: { type: "static" },
        layout: { type: "flex", flex: { direction: "column" } },
      })
      store.addComponent({
        name: "C2",
        semanticTag: "section",
        positioning: { type: "static" },
        layout: { type: "flex", flex: { direction: "column" } },
      })
      store.addComponent({
        name: "C3",
        semanticTag: "section",
        positioning: { type: "static" },
        layout: { type: "flex", flex: { direction: "column" } },
      })

      // Get updated state
      store = useLayoutStore.getState()
      const ids = store.schema.components.map((c) => c.id)

      store.addComponentLink(ids[0], ids[1])
      store.addComponentLink(ids[1], ids[2])

      // Get updated state
      store = useLayoutStore.getState()
      expect(store.componentLinks.length).toBe(2)

      // Delete component ids[1] (should remove all related links)
      store.deleteComponent(ids[1])

      // Get updated state
      store = useLayoutStore.getState()
      const linksAfter = store.componentLinks
      expect(linksAfter.length).toBe(0) // All links involving ids[1] should be removed
      expect(linksAfter.some((link) => link.source === ids[1] || link.target === ids[1])).toBe(false)
    })
  })

  describe("Edge cases with concurrent operations", () => {
    it("should handle clear all links with existing links", () => {
      let store = useLayoutStore.getState()

      // Add components and multiple links
      for (let i = 0; i < 5; i++) {
        store.addComponent({
          name: `Component${i + 1}`,
          semanticTag: "section",
          positioning: { type: "static" },
          layout: { type: "flex", flex: { direction: "column" } },
        })
      }

      // Get updated state
      store = useLayoutStore.getState()
      const ids = store.schema.components.map((c) => c.id)

      // Create a complex network
      store.addComponentLink(ids[0], ids[1])
      store.addComponentLink(ids[1], ids[2])
      store.addComponentLink(ids[2], ids[3])
      store.addComponentLink(ids[3], ids[4])

      // Get updated state
      store = useLayoutStore.getState()
      expect(store.componentLinks.length).toBeGreaterThan(0)

      // Clear all links
      store.clearAllLinks()

      // Get updated state
      store = useLayoutStore.getState()
      expect(store.componentLinks.length).toBe(0)
    })

    it("should handle mergeLinkedComponents after multiple operations", () => {
      let store = useLayoutStore.getState()

      // Add components in mobile breakpoint
      store.addComponent({
        name: "Header",
        semanticTag: "header",
        positioning: { type: "sticky", position: { top: 0 } },
        layout: { type: "flex", flex: { direction: "row" } },
        responsiveCanvasLayout: {
          mobile: { x: 0, y: 0, width: 12, height: 1 },
        },
      })

      // Switch to tablet and add another header
      store.setCurrentBreakpoint("tablet")
      store.addComponent({
        name: "Header",
        semanticTag: "header",
        positioning: { type: "sticky", position: { top: 0 } },
        layout: { type: "flex", flex: { direction: "row" } },
        responsiveCanvasLayout: {
          tablet: { x: 0, y: 0, width: 12, height: 1 },
        },
      })

      // Get updated state
      store = useLayoutStore.getState()
      const ids = store.schema.components.map((c) => c.id)

      // Link them
      store.addComponentLink(ids[0], ids[1])

      // Merge
      store.mergeLinkedComponents()

      // Get updated state
      store = useLayoutStore.getState()

      // After merge, should have combined responsiveCanvasLayout
      const components = store.schema.components
      expect(components.length).toBe(1) // Should be merged into one

      const merged = components[0]
      expect(merged.responsiveCanvasLayout).toBeDefined()
      expect(merged.responsiveCanvasLayout?.mobile).toBeDefined()
      expect(merged.responsiveCanvasLayout?.tablet).toBeDefined()
    })

    it("should handle auto-link similar components", () => {
      let store = useLayoutStore.getState()

      // Add components with same name
      store.addComponent({
        name: "Header",
        semanticTag: "header",
        positioning: { type: "sticky", position: { top: 0 } },
        layout: { type: "flex", flex: { direction: "row" } },
      })

      store.addComponent({
        name: "Header",
        semanticTag: "header",
        positioning: { type: "sticky", position: { top: 0 } },
        layout: { type: "flex", flex: { direction: "row" } },
      })

      store.addComponent({
        name: "Footer",
        semanticTag: "footer",
        positioning: { type: "static" },
        layout: { type: "flex", flex: { direction: "row" } },
      })

      // Get updated state
      store = useLayoutStore.getState()
      const ids = store.schema.components.map((c) => c.id)

      // Auto-link similar components
      store.autoLinkSimilarComponents()

      // Get updated state
      store = useLayoutStore.getState()
      const links = store.componentLinks
      expect(links.length).toBeGreaterThan(0)

      // ids[0] and ids[1] should be linked (same name)
      const group = store.getLinkedComponentGroup(ids[0])
      expect(group).toContain(ids[0])
      expect(group).toContain(ids[1])
      expect(group).not.toContain(ids[2]) // Different name
    })
  })

  describe("Performance and consistency", () => {
    it("should maintain consistency with many components and links", () => {
      let store = useLayoutStore.getState()

      // Add many components
      const numComponents = 20
      for (let i = 0; i < numComponents; i++) {
        store.addComponent({
          name: `Component${i + 1}`,
          semanticTag: "section",
          positioning: { type: "static" },
          layout: { type: "flex", flex: { direction: "column" } },
        })
      }

      // Get updated state
      store = useLayoutStore.getState()
      const ids = store.schema.components.map((c) => c.id)

      // Create a chain of links
      for (let i = 0; i < numComponents - 1; i++) {
        store.addComponentLink(ids[i], ids[i + 1])
      }

      // Get updated state
      store = useLayoutStore.getState()
      const links = store.componentLinks
      expect(links.length).toBe(numComponents - 1)

      // All components should be in the same group
      const group = store.getLinkedComponentGroup(ids[0])
      expect(group.length).toBe(numComponents)
    })
  })
})
